static(정적)
static 변수(정적변수),
static 메서드(정적메서드)

객체 new생성자() 했을때 생성됨
Student s1;
(name,grade)
s = new Student();
Student s1= new Student();
s1.setName("홍길동");
1.name
Student s2= new Student();
s2.setName("이순신");
s2.name

인스턴스

클래스1
변수  
- 인스턴수변수(각 객체가 가지고 있는 변수)
- static 변수(클래스 당 하나, 모든 객체가 공유하는 변수)	
 모든 객체가 동일한 값을 가지는 변수가 존재할 때, 객체마다 해당 변수를 생성하여주면 
 동일한 값을 가지는 변수가 계속 생성되는 것이다.
그래서 모든 객체가 똑같은 데이터를 가지는 변수를 사용할 때는 static 변수를 이용한다.


메서드
static method :
객체의 상태와 상관없이 항상 동일 한 동작을 할때static 으로 선언

static 변수와, static method는
static way( 클래스 이름으로 접근)로 사용 한다.
객체가 없어도 사용할 수 있기 때문에 접근하는 방식은 옳지 못하다.
static 변수에서는 non-static변수를 사용할 수 없다




생성자


inheritance(상속)=코드를 재사용하기 위한 기법


접근제한자(public/private/protected/(default))
public : 외부 클래스에서 접근을 허용
ex)class Car
{
    int speed;

}
ex)class SportsCar extends Car          

{
    int turbo;
}
 //SportCar class(상속받은class)를 만들어 
extends Car(상속을해주는class(super class=부모클래스))를 해서 class Car 기능을 추가   




접근제한자(public/private/protected/(default))
public : 외부클래스에서 접근을 허용 
private : 외부클래스에서 접근을 허용하지 않음
(default): 접근제한자를 적어주지 않았을 때, 
                            같은 패키지 내에 있는 클래스라면 접근을 허용, 다른패키지라면 접근 허용X

protected : 아무 접근제한자를 적어주지 않알을 경우(default)와 동일하나 상속관계에 있는 경우, 접근을 허용                            
                            


상속관계 : ~은~이다.(is-a) ex)원은 점이다
포함관계 : ~은~을 가지고 있다(has-a) ex)원은 점을 가지고 있다   


부모클래스 : 상속을 해주는 클래스
자식클래스 : 상속을 받는 클래스

자식클래스는 부모클래스에 선언된 변수나, 메서드를 포함하고 있다.
자식클래스의 객체를 만들때는 부모클래스의 객체도 함께 생성이 된다.
-자식클래스의 생성자가 호출되면, 생성자의 가장 맨 윗줄에서는 부모클래스의 생성자가 호출되어야한다.
만약, 호출하지 않으면 부모클래스의 기본생성자가 생략되어 있는것과 같다.
부모클래스의 생성자super();(조상이 여러개다라고 한다면 직계 조상을 의미한다)

super
자식클래스에서 부모클래스의 객체를 지칭하는 키워드



자식클래스의 객체는 부모클래스의 객체도 포함하고 있으므로, 부모 객체처럼 취급할 수 있다.
(자시클래스의 객체는 부모클래스의 참조 변수에 참조할 수 있다,
is-a관계에 있을때ㅡ 객체는 참조 가능하다)

스포츠카는 자동차이다. SportsCar is a car.
예) Car c1 = new SportsCar();

 c1<<<부모클래스에 자식클래스가 참조되어 있더라도, 부모클래스의 참조변수를 통해서는
 자식클래스의 기능,변수를 사용할 수 없다.
 굳이 사용하고 싶다면...형변환을 토앻서 사용해야 한다.
SportsCar c2 = (SpsortCar)c1;
C2.turboOn();  
((SpsortCar)c1).turbonOn();

                        		
Car is a SportCar ? 거짓
   SportsCar myCar = new Car(); xxxxxx
   
instanceof : 인스턴스가 어느 클래스의 객체인지 확인하는 연산자
(특히 부모클래스의 참조변수에 참조되어있는 객체가 어떤 자식클래스의 객체인지 확인할 때 사용) 
                          		
매서드 오버로딩(overloading):중복메서드 vs 메서드 오버라이딩(메서드 재정의)
메서드 오버로딩 : 이름만 같은 메서드를 여러개 정의
		 : 비슷한 기능을 가지는 메서드의 이름을 하나로 통일해서 사용하기 쉽게 하는 작업 
		 : 매개변수를 달리해서 여러 동작을 하는 메서드의 이름을 통일한다.
		 ex)println(5), println("hello"), println(true)
                       		
메서드 오버라이딩  : 부모클래스에 정의된 메서드를 다시 작성하는 것 
		   : 부모클래스가 가지는 메서드와 똑같은 형태(이름,반환형,매개변수)를 가지고 있어야함                       		
           : 내용만 다시 작성 
           
>>>>>>>>>>>>>>>>>>             		
오버라이딩을 하는 이유는  새로운 메서드가 들어왔을때 그 메서드에서 기존 기능을 추가 하게 되면 기존의 메서드도 변경해야 하기때문에
그 작업을 안하기 위해서 기존의 메서드 기능에서 추가만 하면 되기때문에                		
                        		
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
shape(도형)
protected
-Circle, Rectangle, Triangle      
area(실수),numOfLines(정수),name(문자열)
생성자(기본생성자,멤버변수 입력받아서 초기화하는 생성자)
getter/setter
draw() 도형을 그립니다.출력
calArea() area = 0;
toString(오버라이딩)

-Circle, Rectangle, Triangle  shape를 상속
draw(),calArea(),toString() 오버라이딩   
      
      
//상속 및 동적바인딩(다형성) 실습합니다
		//1. 상속시, 자식클래스의 객체는 부모 클래스의 참조변수에 참조 가능하다.
		//2. 자식클래스의 객체가 부모클래스의 참조변수에 참조 되어 있으면
		//   자식클래스에서 새롭게 선언된 변수나, 메서드는 참조하지 못한다.
		//   사용하려면 자식클래스로 형변환이 필요하다.
		//3. 자식클래스에서 부모클래스가 가지는 메서드를 재정의 하였다면
		//   (오버라이딩 하였다면) 부모 클래스의 참조 변수에서 메서드를 실행하더라도
		//    자식클래스에 오버라이딩 된 메서드가 실행된다(동적바인딩)>> 다형성                        		
                    		
                        		
                        		
                        		